#!/usr/bin/env python3
import logging
import argparse
import os
import re
import sys
import json
import zipfile
import subprocess
from bs4 import BeautifulSoup

DEFAULT_MAVEN = os.path.join(os.environ["HOME"], ".m2")
DEFAULT_OUTPUT = os.path.join(os.environ["HOME"], "jdoc")
FILENAME_CLASSNAMES = "_classnames.json"


def index_maven(repodir, outputdir):
    if not os.path.exists(repodir):
        logging.warning("Maven repo does not exist: %s", repodir)
        return
    logging.info("Indexing Maven repo: %s", repodir)
    os.makedirs(outputdir, exist_ok=True)
    for root, dirnames, filenames in os.walk(repodir):
        for filename in filenames:
            if filename.endswith("-javadoc.jar"):
                pathname_input = os.path.join(root, filename)
                pathname_output = os.path.join(outputdir, filename)
                if not os.path.exists(pathname_output):
                    logging.debug(
                        "Extracting %s to %s", pathname_input, pathname_output
                    )
                    os.makedirs(pathname_output, exist_ok=True)
                    with zipfile.ZipFile(pathname_input) as zf:
                        zf.extractall(pathname_output)


def parse_classnames(root, tree):
    return [
        dict(
            name=elt["href"].replace(".html", "").replace("/", "."),
            path=elt["href"],
            jar=os.path.basename(root),
        )
        for elt in tree.select("li a")
    ]


def index_classnames(outputdir):
    classnames = []
    for root, dirnames, filenames in os.walk(outputdir):
        for filename in filenames:
            if filename == "allclasses-noframe.html":
                pathname = os.path.join(root, filename)
                logging.debug("Processing %s", pathname)
                with open(pathname) as f:
                    tree = BeautifulSoup(f, "html.parser")
                    classnames.extend(parse_classnames(root, tree))
    with open(os.path.join(outputdir, FILENAME_CLASSNAMES), "w") as f:
        json.dump(classnames, f)


def index(mavendir, outputdir):
    index_maven(mavendir, outputdir)
    index_classnames(outputdir)


def load_classnames(dirname):
    with open(os.path.join(dirname, FILENAME_CLASSNAMES)) as f:
        return json.load(f)


def classname_matches(classname, patterns, flags=0):
    if not patterns:
        return True
    for pattern in patterns:
        if re.search(pattern, classname["name"], flags) or re.search(
            pattern, classname["jar"], flags
        ):
            return True
    return False


def search(dirname, patterns, ignorecase=False):
    flags = 0
    if ignorecase:
        flags |= re.IGNORECASE
    matches = sorted(
        [
            classname
            for classname in load_classnames(dirname)
            if classname_matches(classname, patterns, flags=flags)
        ],
        key=lambda x: (x["name"], x["jar"]),
    )
    for match in matches:
        pathname = os.path.join(dirname, match["jar"], match["path"])
        logging.info("%s (file://%s)", match["name"], pathname)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("--index", action="store_true")
    parser.add_argument("-m", "--maven_repo", default=DEFAULT_MAVEN)
    parser.add_argument("-o", "--output", default=DEFAULT_OUTPUT)
    parser.add_argument("-i", "--ignorecase", action="store_true")
    parser.add_argument("--debug", action="store_true")
    parser.add_argument("patterns", nargs="*")
    args = parser.parse_args()
    logging.basicConfig(
        format="%(message)s",
        level=logging.DEBUG if args.debug else logging.INFO,
        stream=sys.stdout,
    )
    if args.index:
        index(args.maven_repo, args.output)
    else:
        search(args.output, args.patterns, ignorecase=args.ignorecase)
